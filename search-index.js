var N = null;var searchIndex = {};
searchIndex["rustacuda"]={"doc":"This crate provides a safe, user-friendly wrapper around the CUDA Driver API.","items":[[3,"CudaFlags","rustacuda","Bit flags for initializing the CUDA driver. Currently, no flags are defined, so `CudaFlags::empty()` is the only valid value.",N,N],[3,"CudaApiVersion","","Struct representing the CUDA API version number.",N,N],[5,"init","","Initialize the CUDA Driver API.",N,[[["cudaflags"]],["cudaresult"]]],[5,"quick_init","","Shortcut for initializing the CUDA Driver API and creating a CUDA context with default settings for the first device.",N,[[],["cudaresult",["context"]]]],[0,"context","","CUDA context management",N,N],[3,"ContextFlags","rustacuda::context","Bit flags for initializing the CUDA context.",N,N],[3,"Context","","Owned handle to a CUDA context.",N,N],[3,"UnownedContext","","Non-owning handle to a CUDA context.",N,N],[3,"ContextStack","","Type used to represent the thread-local context stack.",N,N],[3,"StreamPriorityRange","","Struct representing a range of stream priorities.",N,N],[12,"least","","The least stream priority",0,N],[12,"greatest","","The greatest stream priority",0,N],[3,"CurrentContext","","Type representing the top context in the thread-local stack.",N,N],[4,"CacheConfig","","This enumeration represents configuration settings for devices which share hardware resources between L1 cache and shared memory.",N,N],[13,"PreferNone","","No preference for shared memory or L1 (default)",1,N],[13,"PreferShared","","Prefer larger shared memory and smaller L1 cache",1,N],[13,"PreferL1","","Prefer larger L1 cache and smaller shared memory",1,N],[13,"PreferEqual","","Prefer equal-sized L1 cache and shared memory",1,N],[4,"ResourceLimit","","This enumeration represents the limited resources which can be accessed through CurrentContext::get_resource_limit and CurrentContext::set_resource_limit.",N,N],[13,"StackSize","","The size in bytes of each GPU thread stack",2,N],[13,"PrintfFifoSize","","The size in bytes of the FIFO used by the `printf()` device system call.",2,N],[13,"MallocHeapSize","","The size in bytes of the heap used by the `malloc()` and `free()` device system calls.",2,N],[13,"DeviceRuntimeSynchronizeDepth","","The maximum nesting depth of a grid at which a thread can safely call `cudaDeviceSynchronize()` to wait on child grid launches to complete.",2,N],[13,"DeviceRuntimePendingLaunchCount","","The maximum number of outstanding device runtime launches that can be made from the current context.",2,N],[13,"MaxL2FetchGranularity","","L2 cache fetch granularity",2,N],[4,"SharedMemoryConfig","","This enumeration represents the options for configuring the shared memory bank size.",N,N],[13,"DefaultBankSize","","Set shared-memory bank size to the default.",3,N],[13,"FourByteBankSize","","Set shared-memory bank width to four bytes",3,N],[13,"EightByteBankSize","","Set shared-memory bank width to eight bytes",3,N],[8,"ContextHandle","","Sealed trait for `Context` and `UnownedContext`. Not intended for use outside of RustaCUDA.",N,N],[18,"SCHED_SPIN","","Instructs CUDA to actively spin when waiting for results from the GPU. This can decrease latency when waiting for the GPU, but may lower the performance of other CPU threads if they are performing work in parallel with the CUDA thread.",4,N],[18,"SCHED_YIELD","","Instructs CUDA to yield its thread when waiting for results from the GPU. This can increase latency when waiting for the GPU, but can increase the performance of CPU threads performing work in parallel with the GPU.",4,N],[18,"SCHED_BLOCKING_SYNC","","Instructs CUDA to block the CPU thread on a synchronization primitive when waiting for the GPU to finish work.",4,N],[18,"SCHED_AUTO","","Instructs CUDA to automatically choose whether to yield to other OS threads while waiting for the GPU, or to spin the OS thread. This is the default.",4,N],[18,"MAP_HOST","","Instructs CUDA to support mapped pinned allocations. This flag must be set in order to use page-locked memory (see LockedBuffer).",4,N],[18,"LMEM_RESIZE_TO_MAX","","Instruct CUDA not to reduce local memory after resizing local memory for a kernel. This can prevent thrashing by local memory allocations when launching many kernels with high local memory usage at the cost of potentially increased memory usage.",4,N],[11,"empty","","Returns an empty set of flags.",4,[[],["contextflags"]]],[11,"all","","Returns the set containing all flags.",4,[[],["contextflags"]]],[11,"bits","","Returns the raw value of the flags currently stored.",4,[[["self"]],["u32"]]],[11,"from_bits","","Convert from underlying bit representation, unless that representation contains bits that do not correspond to a flag.",4,[[["u32"]],["option",["contextflags"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits that do not correspond to flags.",4,[[["u32"]],["contextflags"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",4,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",4,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",4,[[["self"],["contextflags"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",4,[[["self"],["contextflags"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",4,[[["self"],["contextflags"]]]],[11,"remove","","Removes the specified flags in-place.",4,[[["self"],["contextflags"]]]],[11,"toggle","","Toggles the specified flags in-place.",4,[[["self"],["contextflags"]]]],[11,"set","","Inserts or removes the specified flags depending on the passed value.",4,[[["self"],["contextflags"],["bool"]]]],[11,"create_and_push","","Create a CUDA context for the given device.",5,[[["contextflags"],["device"]],["cudaresult",["context"]]]],[11,"get_api_version","","Get the API version used to create this context.",5,[[["self"]],["cudaresult",["cudaapiversion"]]]],[11,"get_unowned","","Returns an non-owning handle to this context.",5,[[["self"]],["unownedcontext"]]],[11,"drop","","Destroy a `Context`, returning an error.",5,[[["context"]],["dropresult",["context"]]]],[11,"get_api_version","","Get the API version used to create this context.",6,[[["self"]],["cudaresult",["cudaapiversion"]]]],[11,"pop","","Pop the current context off the stack and return the handle. That context may then be made current again (perhaps on a different CPU thread) by calling push.",7,[[],["cudaresult",["unownedcontext"]]]],[11,"push","","Push the given context to the top of the stack",7,[[["c"]],["cudaresult"]]],[11,"get_cache_config","","Returns the preferred cache configuration for the current context.",8,[[],["cudaresult",["cacheconfig"]]]],[11,"get_device","","Return the device ID for the current context.",8,[[],["cudaresult",["device"]]]],[11,"get_flags","","Return the context flags for the current context.",8,[[],["cudaresult",["contextflags"]]]],[11,"get_resource_limit","","Return resource limits for the current context.",8,[[["resourcelimit"]],["cudaresult",["usize"]]]],[11,"get_shared_memory_config","","Return resource limits for the current context.",8,[[],["cudaresult",["sharedmemoryconfig"]]]],[11,"get_stream_priority_range","","Return the least and greatest stream priorities.",8,[[],["cudaresult",["streampriorityrange"]]]],[11,"set_cache_config","","Sets the preferred cache configuration for the current context.",8,[[["cacheconfig"]],["cudaresult"]]],[11,"set_resource_limit","","Sets a requested resource limit for the current context.",8,[[["resourcelimit"],["usize"]],["cudaresult"]]],[11,"set_shared_memory_config","","Sets the preferred shared memory configuration for the current context.",8,[[["sharedmemoryconfig"]],["cudaresult"]]],[11,"get_current","","Returns a non-owning handle to the current context.",8,[[],["cudaresult",["unownedcontext"]]]],[11,"set_current","","Set the given context as the current context for this thread.",8,[[["c"]],["cudaresult"]]],[11,"synchronize","","Block to wait for a context's tasks to complete.",8,[[],["cudaresult"]]],[0,"device","rustacuda","Functions and types for enumerating CUDA devices and retrieving information about them.",N,N],[3,"Device","rustacuda::device","Opaque handle to a CUDA device.",N,N],[3,"Devices","","Iterator over all available CUDA devices. See the Device::devices function for more information.",N,N],[4,"DeviceAttribute","","All supported device attributes for Device::get_attribute",N,N],[13,"MaxThreadsPerBlock","","Maximum number of threads per block",9,N],[13,"MaxBlockDimX","","Maximum x-dimension of a block",9,N],[13,"MaxBlockDimY","","Maximum y-dimension of a block",9,N],[13,"MaxBlockDimZ","","Maximum z-dimension of a block",9,N],[13,"MaxGridDimX","","Maximum x-dimension of a grid",9,N],[13,"MaxGridDimY","","Maximum y-dimension of a grid",9,N],[13,"MaxGridDimZ","","Maximum a-dimension of a grid",9,N],[13,"MaxSharedMemoryPerBlock","","Maximum amount of shared memory available to a thread block in bytes",9,N],[13,"TotalConstantMemory","","Memory available on device for constant variables in a kernel in bytes",9,N],[13,"WarpSize","","Warp size in threads",9,N],[13,"MaxPitch","","Maximum pitch in bytes allowed by the memory copy functions that involve memory regions allocated through cuMemAllocPitch()",9,N],[13,"MaxRegistersPerBlock","","Maximum number of 32-bit registers available to a thread block",9,N],[13,"ClockRate","","Typical clock frequency in kilohertz",9,N],[13,"TextureAlignment","","Alignment requirement for textures",9,N],[13,"MultiprocessorCount","","Number of multiprocessors on device.",9,N],[13,"KernelExecTimeout","","Specifies whether there is a run time limit on kernels",9,N],[13,"Integrated","","Device is integrated with host memory",9,N],[13,"CanMapHostMemory","","Device can map host memory into CUDA address space",9,N],[13,"ComputeMode","","Compute Mode",9,N],[13,"MaximumTexture1DWidth","","Maximum 1D texture width",9,N],[13,"MaximumTexture2DWidth","","Maximum 2D texture width",9,N],[13,"MaximumTexture2DHeight","","Maximum 2D texture height",9,N],[13,"MaximumTexture3DWidth","","Maximum 3D texture width",9,N],[13,"MaximumTexture3DHeight","","Maximum 3D texture height",9,N],[13,"MaximumTexture3DDepth","","Maximum 3D texture depth",9,N],[13,"MaximumTexture2DLayeredWidth","","Maximum 2D layered texture width",9,N],[13,"MaximumTexture2DLayeredHeight","","Maximum 2D layered texture height",9,N],[13,"MaximumTexture2DLayeredLayers","","Maximum layers in a 2D layered texture",9,N],[13,"SurfaceAlignment","","Alignment requirement for surfaces",9,N],[13,"ConcurrentKernels","","Device can possibly execute multiple kernels concurrently",9,N],[13,"EccEnabled","","Device has ECC support enabled",9,N],[13,"PciBusId","","PCI bus ID of the device",9,N],[13,"PciDeviceId","","PCI device ID of the device",9,N],[13,"TccDriver","","Device is using TCC driver model",9,N],[13,"MemoryClockRate","","Peak memory clock frequency in kilohertz",9,N],[13,"GlobalMemoryBusWidth","","Global memory bus width in bits",9,N],[13,"L2CacheSize","","Size of L2 cache in bytes.",9,N],[13,"MaxThreadsPerMultiprocessor","","Maximum resident threads per multiprocessor",9,N],[13,"AsyncEngineCount","","Number of asynchronous engines",9,N],[13,"UnifiedAddressing","","Device shares a unified address space with the host",9,N],[13,"MaximumTexture1DLayeredWidth","","Maximum 1D layered texture width",9,N],[13,"MaximumTexture1DLayeredLayers","","Maximum layers in a 1D layered texture",9,N],[13,"MaximumTexture2DGatherWidth","","Maximum 2D texture width if CUDA_ARRAY3D_TEXTURE_GATHER is set",9,N],[13,"MaximumTexture2DGatherHeight","","Maximum 2D texture height if CUDA_ARRAY3D_TEXTURE_GATHER is set",9,N],[13,"MaximumTexture3DWidthAlternate","","Alternate maximum 3D texture width",9,N],[13,"MaximumTexture3DHeightAlternate","","Alternate maximum 3D texture height",9,N],[13,"MaximumTexture3DDepthAlternate","","Alternate maximum 3D texture depth",9,N],[13,"PciDomainId","","PCI domain ID of the device",9,N],[13,"TexturePitchAlignment","","Pitch alignment requirement for textures",9,N],[13,"MaximumTextureCubemapWidth","","Maximum cubemap texture width/height",9,N],[13,"MaximumTextureCubemapLayeredWidth","","Maximum cubemap layered texture width/height",9,N],[13,"MaximumTextureCubemapLayeredLayers","","Maximum layers in a cubemap layered texture",9,N],[13,"MaximumSurface1DWidth","","Maximum 1D surface width",9,N],[13,"MaximumSurface2DWidth","","Maximum 2D surface width",9,N],[13,"MaximumSurface2DHeight","","Maximum 2D surface height",9,N],[13,"MaximumSurface3DWidth","","Maximum 3D surface width",9,N],[13,"MaximumSurface3DHeight","","Maximum 3D surface height",9,N],[13,"MaximumSurface3DDepth","","Maximum 3D surface depth",9,N],[13,"MaximumSurface1DLayeredWidth","","Maximum 1D layered surface width",9,N],[13,"MaximumSurface1DLayeredLayers","","Maximum layers in a 1D layered surface",9,N],[13,"MaximumSurface2DLayeredWidth","","Maximum 2D layered surface width",9,N],[13,"MaximumSurface2DLayeredHeight","","Maximum 2D layered surface height",9,N],[13,"MaximumSurface2DLayeredLayers","","Maximum layers in a 2D layered surface",9,N],[13,"MaximumSurfacecubemapWidth","","Maximum cubemap surface width",9,N],[13,"MaximumSurfacecubemapLayeredWidth","","Maximum cubemap layered surface width",9,N],[13,"MaximumSurfacecubemapLayeredLayers","","Maximum layers in a cubemap layered surface",9,N],[13,"MaximumTexture1DLinearWidth","","Maximum 1D linear texture width",9,N],[13,"MaximumTexture2DLinearWidth","","Maximum 2D linear texture width",9,N],[13,"MaximumTexture2DLinearHeight","","Maximum 2D linear texture height",9,N],[13,"MaximumTexture2DLinearPitch","","Maximum 2D linear texture pitch in bytes",9,N],[13,"MaximumTexture2DMipmappedWidth","","Maximum mipmapped 2D texture height",9,N],[13,"MaximumTexture2DMipmappedHeight","","Maximum mipmapped 2D texture width",9,N],[13,"ComputeCapabilityMajor","","Major compute capability version number",9,N],[13,"ComputeCapabilityMinor","","Minor compute capability version number",9,N],[13,"MaximumTexture1DMipmappedWidth","","Maximum mipammed 1D texture width",9,N],[13,"StreamPrioritiesSupported","","Device supports stream priorities",9,N],[13,"GlobalL1CacheSupported","","Device supports caching globals in L1",9,N],[13,"LocalL1CacheSupported","","Device supports caching locals in L1",9,N],[13,"MaxSharedMemoryPerMultiprocessor","","Maximum shared memory available per multiprocessor in bytes",9,N],[13,"MaxRegistersPerMultiprocessor","","Maximum number of 32-bit registers available per multiprocessor",9,N],[13,"ManagedMemory","","Device can allocate managed memory on this system",9,N],[13,"MultiGpuBoard","","Device is on a multi-GPU board",9,N],[13,"MultiGpuBoardGroupId","","Unique ID for a group of devices on the same multi-GPU board",9,N],[13,"HostNativeAtomicSupported","","Link between the device and the host supports native atomic operations (this is a placeholder attribute and is not supported on any current hardware)",9,N],[13,"SingleToDoublePrecisionPerfRatio","","Ratio of single precision performance (in floating-point operations per second) to double precision performance",9,N],[13,"PageableMemoryAccess","","Device supports coherently accessing pageable memory without calling cudaHostRegister on it.",9,N],[13,"ConcurrentManagedAccess","","Device can coherently access managed memory concurrently with the CPU",9,N],[13,"ComputePreemptionSupported","","Device supports compute preemption",9,N],[13,"CanUseHostPointerForRegisteredMem","","Device can access host registered memory at the same virtual address as the CPU",9,N],[11,"num_devices","","Get the number of CUDA-capable devices.",10,[[],["cudaresult",["u32"]]]],[11,"get_device","","Get a handle to the `ordinal`'th CUDA device.",10,[[["u32"]],["cudaresult",["device"]]]],[11,"devices","","Return an iterator over all CUDA devices.",10,[[],["cudaresult",["devices"]]]],[11,"total_memory","","Returns the total amount of memory available on the device in bytes.",10,[[["self"]],["cudaresult",["usize"]]]],[11,"name","","Returns the name of this device.",10,[[["self"]],["cudaresult",["string"]]]],[11,"get_attribute","","Returns information about this device.",10,[[["self"],["deviceattribute"]],["cudaresult",["i32"]]]],[0,"error","rustacuda","Types for error handling",N,N],[4,"CudaError","rustacuda::error","Error enum which represents all the potential errors returned by the CUDA driver API.",N,N],[13,"InvalidValue","","",11,N],[13,"OutOfMemory","","",11,N],[13,"NotInitialized","","",11,N],[13,"Deinitialized","","",11,N],[13,"ProfilerDisabled","","",11,N],[13,"ProfilerNotInitialized","","",11,N],[13,"ProfilerAlreadyStarted","","",11,N],[13,"ProfilerAlreadyStopped","","",11,N],[13,"NoDevice","","",11,N],[13,"InvalidDevice","","",11,N],[13,"InvalidImage","","",11,N],[13,"InvalidContext","","",11,N],[13,"ContextAlreadyCurrent","","",11,N],[13,"MapFailed","","",11,N],[13,"UnmapFailed","","",11,N],[13,"ArrayIsMapped","","",11,N],[13,"AlreadyMapped","","",11,N],[13,"NoBinaryForGpu","","",11,N],[13,"AlreadyAcquired","","",11,N],[13,"NotMapped","","",11,N],[13,"NotMappedAsArray","","",11,N],[13,"NotMappedAsPointer","","",11,N],[13,"EccUncorrectable","","",11,N],[13,"UnsupportedLimit","","",11,N],[13,"ContextAlreadyInUse","","",11,N],[13,"PeerAccessUnsupported","","",11,N],[13,"InvalidPtx","","",11,N],[13,"InvalidGraphicsContext","","",11,N],[13,"NvlinkUncorrectable","","",11,N],[13,"InvalidSouce","","",11,N],[13,"FileNotFound","","",11,N],[13,"SharedObjectSymbolNotFound","","",11,N],[13,"SharedObjectInitFailed","","",11,N],[13,"OperatingSystemError","","",11,N],[13,"InvalidHandle","","",11,N],[13,"NotFound","","",11,N],[13,"NotReady","","",11,N],[13,"IllegalAddress","","",11,N],[13,"LaunchOutOfResources","","",11,N],[13,"LaunchTimeout","","",11,N],[13,"LaunchIncompatibleTexturing","","",11,N],[13,"PeerAccessAlreadyEnabled","","",11,N],[13,"PeerAccessNotEnabled","","",11,N],[13,"PrimaryContextActive","","",11,N],[13,"ContextIsDestroyed","","",11,N],[13,"AssertError","","",11,N],[13,"TooManyPeers","","",11,N],[13,"HostMemoryAlreadyRegistered","","",11,N],[13,"HostMemoryNotRegistered","","",11,N],[13,"HardwareStackError","","",11,N],[13,"IllegalInstruction","","",11,N],[13,"MisalignedAddress","","",11,N],[13,"InvalidAddressSpace","","",11,N],[13,"InvalidProgramCounter","","",11,N],[13,"LaunchFailed","","",11,N],[13,"NotPermitted","","",11,N],[13,"NotSupported","","",11,N],[13,"UnknownError","","",11,N],[13,"InvalidMemoryAllocation","","",11,N],[6,"CudaResult","","Result type for most CUDA functions.",N,N],[6,"DropResult","","Special result type for `drop` functions which includes the un-dropped value with the error.",N,N],[0,"function","rustacuda","Functions and types for working with CUDA kernels.",N,N],[3,"GridSize","rustacuda::function","Dimensions of a grid, or the number of thread blocks in a kernel launch.",N,N],[12,"x","","Width of grid in blocks",12,N],[12,"y","","Height of grid in blocks",12,N],[12,"z","","Depth of grid in blocks",12,N],[3,"BlockSize","","Dimensions of a thread block, or the number of threads in a block.",N,N],[12,"x","","X dimension of each thread block",13,N],[12,"y","","Y dimension of each thread block",13,N],[12,"z","","Z dimension of each thread block",13,N],[3,"Function","","Handle to a global kernel function.",N,N],[4,"FunctionAttribute","","All supported function attributes for Function::get_attribute",N,N],[13,"MaxThreadsPerBlock","","The maximum number of threads per block, beyond which a launch would fail. This depends on both the function and the device.",14,N],[13,"SharedMemorySizeBytes","","The size in bytes of the statically-allocated shared memory required by this function.",14,N],[13,"ConstSizeBytes","","The size in bytes of the constant memory required by this function",14,N],[13,"LocalSizeBytes","","The size in bytes of local memory used by each thread of this function",14,N],[13,"NumRegisters","","The number of registers used by each thread of this function",14,N],[13,"PtxVersion","","The PTX virtual architecture version for which the function was compiled. This value is the major PTX version * 10 + the minor PTX version, so version 1.3 would return the value 13.",14,N],[13,"BinaryVersion","","The binary architecture version for which the function was compiled. Encoded the same way as PtxVersion.",14,N],[13,"CacheModeCa","","The attribute to indicate whether the function has been compiled with user specified option \"-Xptxas --dlcm=ca\" set.",14,N],[11,"x","","Create a one-dimensional grid of `x` blocks",12,[[["u32"]],["gridsize"]]],[11,"xy","","Create a two-dimensional grid of `x * y` blocks",12,[[["u32"],["u32"]],["gridsize"]]],[11,"xyz","","Create a three-dimensional grid of `x * y * z` blocks",12,[[["u32"],["u32"],["u32"]],["gridsize"]]],[11,"x","","Create a one-dimensional block of `x` threads",13,[[["u32"]],["blocksize"]]],[11,"xy","","Create a two-dimensional block of `x * y` threads",13,[[["u32"],["u32"]],["blocksize"]]],[11,"xyz","","Create a three-dimensional block of `x * y * z` threads",13,[[["u32"],["u32"],["u32"]],["blocksize"]]],[11,"get_attribute","","Returns information about a function.",15,[[["self"],["functionattribute"]],["cudaresult",["i32"]]]],[11,"set_cache_config","","Sets the preferred cache configuration for this function.",15,[[["self"],["cacheconfig"]],["cudaresult"]]],[11,"set_shared_memory_config","","Sets the preferred shared memory configuration for this function.",15,[[["self"],["sharedmemoryconfig"]],["cudaresult"]]],[0,"memory","rustacuda","Access to CUDA's memory allocation and transfer functions.",N,N],[8,"DeviceCopy","rustacuda::memory","Marker trait for types which can safely be copied to or from a CUDA device.",N,N],[3,"DevicePointer","","A pointer to device memory.",N,N],[3,"UnifiedPointer","","A pointer to unified memory.",N,N],[3,"DeviceBox","","A pointer type for heap-allocation in CUDA device memory.",N,N],[3,"DeviceBuffer","","Fixed-size device-side buffer. Provides basic access to device memory.",N,N],[3,"DeviceSlice","","Fixed-size device-side slice.",N,N],[3,"DeviceChunks","","An iterator over a `DeviceSlice` in (non-overlapping) chunks (`chunk_size` elements at a time).",N,N],[3,"DeviceChunksMut","","An iterator over a `DeviceSlice` in (non-overlapping) mutable chunks (`chunk_size` elements at a time).",N,N],[3,"LockedBuffer","","Fixed-size host-side buffer in page-locked memory.",N,N],[3,"UnifiedBox","","A pointer type for heap-allocation in CUDA unified memory.",N,N],[3,"UnifiedBuffer","","Fixed-size buffer in unified memory.",N,N],[5,"cuda_malloc","","Unsafe wrapper around the `cuMemAlloc` function, which allocates some device memory and returns a `DevicePointer` pointing to it. The memory is not cleared.",N,[[["usize"]],["cudaresult",["devicepointer"]]]],[5,"cuda_malloc_unified","","Unsafe wrapper around the `cuMemAllocManaged` function, which allocates some unified memory and returns a `UnifiedPointer` pointing to it. The memory is not cleared.",N,[[["usize"]],["cudaresult",["unifiedpointer"]]]],[5,"cuda_free","","Free memory allocated with `cuda_malloc`.",N,[[["devicepointer"]],["cudaresult"]]],[5,"cuda_free_unified","","Free memory allocated with `cuda_malloc_unified`.",N,[[["unifiedpointer"]],["cudaresult"]]],[5,"cuda_malloc_locked","","Unsafe wrapper around the `cuMemAllocHost` function, which allocates some page-locked host memory and returns a raw pointer pointing to it. The memory is not cleared.",N,[[["usize"]],["cudaresult"]]],[5,"cuda_free_locked","","Free page-locked memory allocated with `cuda_malloc_host`.",N,N],[0,"array","","Routines for allocating and using CUDA Array Objects.",N,N],[3,"ArrayObjectFlags","rustacuda::memory::array","Flags which modify the behavior of CUDA array creation.",N,N],[3,"ArrayDescriptor","","Describes a CUDA Array",N,N],[3,"ArrayObject","","A CUDA Array. Can be bound to a texture or surface.",N,N],[4,"ArrayFormat","","Describes the format used for a CUDA Array.",N,N],[13,"UnsignedInt8","","Unsigned 8-bit integer",16,N],[13,"UnsignedInt16","","Unsigned 16-bit integer",16,N],[13,"UnsignedInt32","","Unsigned 32-bit integer",16,N],[13,"SignedInt8","","Signed 8-bit integer",16,N],[13,"SignedInt16","","Signed 16-bit integer",16,N],[13,"SignedInt32","","Signed 32-bit integer",16,N],[13,"Half","","Half-precision floating point number",16,N],[13,"Float","","Single-precision floating point number",16,N],[11,"from_raw","","Creates ArrayFormat from the CUDA Driver API enum",16,[[["cuarray_format"]],["self"]]],[11,"to_raw","","Converts ArrayFormat to the CUDA Driver API enum",16,[[["self"]],["cuarray_format"]]],[18,"LAYERED","","Enables creation of layered CUDA arrays. When this flag is set, depth specifies the number of layers, not the depth of a 3D array.",17,N],[18,"SURFACE_LDST","","Enables surface references to be bound to the CUDA array.",17,N],[18,"CUBEMAP","","Enables creation of cubemaps. If this flag is set, Width must be equal to Height, and Depth must be six. If the `LAYERED` flag is also set, then Depth must be a multiple of six.",17,N],[18,"TEXTURE_GATHER","","Indicates that the CUDA array will be used for texture gather. Texture gather can only be performed on 2D CUDA arrays.",17,N],[11,"empty","","Returns an empty set of flags.",17,[[],["arrayobjectflags"]]],[11,"all","","Returns the set containing all flags.",17,[[],["arrayobjectflags"]]],[11,"bits","","Returns the raw value of the flags currently stored.",17,[[["self"]],["c_uint"]]],[11,"from_bits","","Convert from underlying bit representation, unless that representation contains bits that do not correspond to a flag.",17,[[["c_uint"]],["option",["arrayobjectflags"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits that do not correspond to flags.",17,[[["c_uint"]],["arrayobjectflags"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",17,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",17,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",17,[[["self"],["arrayobjectflags"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",17,[[["self"],["arrayobjectflags"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",17,[[["self"],["arrayobjectflags"]]]],[11,"remove","","Removes the specified flags in-place.",17,[[["self"],["arrayobjectflags"]]]],[11,"toggle","","Toggles the specified flags in-place.",17,[[["self"],["arrayobjectflags"]]]],[11,"set","","Inserts or removes the specified flags depending on the passed value.",17,[[["self"],["arrayobjectflags"],["bool"]]]],[11,"new","","Creates a default flags object with no flags set.",17,[[],["self"]]],[11,"from_raw","","Constructs an ArrayDescriptor from a CUDA Driver API Array Descriptor.",18,[[["cuda_array3d_descriptor"]],["self"]]],[11,"new","","Constructs an ArrayDescriptor from dimensions, format, num_channels, and flags.",18,N],[11,"from_dims_format","","Creates a new ArrayDescriptor from a set of dimensions and format.",18,N],[11,"dims","","Returns the dimensions of the ArrayDescriptor",18,N],[11,"set_dims","","Sets the dimensions of the ArrayDescriptor",18,N],[11,"width","","Returns the width of the ArrayDescripor",18,[[["self"]],["usize"]]],[11,"set_width","","Sets the width of the ArrayDescriptor",18,[[["self"],["usize"]]]],[11,"height","","Returns the height of the ArrayDescripor",18,[[["self"]],["usize"]]],[11,"set_height","","Sets the height of the ArrayDescriptor",18,[[["self"],["usize"]]]],[11,"depth","","Returns the depth of the ArrayDescripor",18,[[["self"]],["usize"]]],[11,"set_depth","","Sets the depth of the ArrayDescriptor",18,[[["self"],["usize"]]]],[11,"format","","Returns the format of the ArrayDescripor",18,[[["self"]],["arrayformat"]]],[11,"set_format","","Sets the format of the ArrayDescriptor",18,[[["self"],["arrayformat"]]]],[11,"num_channels","","Returns the number of channels in the ArrayDescriptor",18,[[["self"]],["c_uint"]]],[11,"set_num_channels","","Sets the number of channels in the ArrayDescriptor",18,[[["self"],["c_uint"]]]],[11,"flags","","Returns the flags of the ArrayDescriptor",18,[[["self"]],["arrayobjectflags"]]],[11,"set_flags","","Sets the flags of the ArrayDescriptor.",18,[[["self"],["arrayobjectflags"]]]],[11,"from_descriptor","","Constructs a generic ArrayObject from an `ArrayDescriptor`.",19,[[["arraydescriptor"]],["cudaresult"]]],[11,"new","","Allocates a new CUDA Array that is up to 3-dimensions.",19,N],[11,"new_1d","","Allocates a new 1D CUDA Array.",19,[[["usize"],["arrayformat"],["c_uint"]],["cudaresult"]]],[11,"new_2d","","Allocates a new CUDA Array that is up to 2-dimensions.",19,N],[11,"new_layered","","Creates a new Layered 1D or 2D CUDA Array.",19,N],[11,"new_layered_1d","","Creates a new Layered 1D CUDA Array.",19,[[["usize"],["usize"],["arrayformat"],["c_uint"]],["cudaresult"]]],[11,"new_cubemap","","Creates a new Cubemap CUDA Array. The array is represented as 6 side x side 2D arrays.",19,[[["usize"],["arrayformat"],["c_uint"]],["cudaresult"]]],[11,"new_layered_cubemap","","Creates a new Layered Cubemap CUDA Array. The array is represented as multiple 6 side x side 2D arrays.",19,[[["usize"],["usize"],["arrayformat"],["c_uint"]],["cudaresult"]]],[11,"descriptor","","Gets the descriptor associated with this array.",19,[[["self"]],["cudaresult",["arraydescriptor"]]]],[11,"drop","","Try to destroy an `ArrayObject`. Can fail - if it does, returns the CUDA error and the un-destroyed array object",19,[[["arrayobject"]],["dropresult",["arrayobject"]]]],[11,"new","rustacuda::memory","Allocate device memory and place val into it.",20,[[["t"]],["cudaresult"]]],[11,"uninitialized","","Allocate device memory, but do not initialize it.",20,[[],["cudaresult"]]],[11,"zeroed","","Allocate device memory and fill it with zeroes (`0u8`).",20,[[],["cudaresult"]]],[11,"from_raw","","Constructs a DeviceBox from a raw pointer.",20,N],[11,"from_device","","Constructs a DeviceBox from a DevicePointer.",20,[[["devicepointer"]],["self"]]],[11,"into_device","","Consumes the DeviceBox, returning the wrapped DevicePointer.",20,[[["devicebox"]],["devicepointer"]]],[11,"as_device_ptr","","Returns the contained device pointer without consuming the box.",20,[[["self"]],["devicepointer"]]],[11,"drop","","Destroy a `DeviceBox`, returning an error.",20,[[["devicebox"]],["dropresult",["devicebox"]]]],[11,"uninitialized","","Allocate a new device buffer large enough to hold `size` `T`'s, but without initializing the contents.",21,[[["usize"]],["cudaresult"]]],[11,"zeroed","","Allocate a new device buffer large enough to hold `size` `T`'s and fill the contents with zeroes (`0u8`).",21,[[["usize"]],["cudaresult"]]],[11,"from_raw_parts","","Creates a `DeviceBuffer<T>` directly from the raw components of another device buffer.",21,[[["devicepointer"],["usize"]],["devicebuffer"]]],[11,"drop","","Destroy a `DeviceBuffer`, returning an error.",21,[[["devicebuffer"]],["dropresult",["devicebuffer"]]]],[11,"from_slice","","Allocate a new device buffer of the same size as `slice`, initialized with a clone of the data in `slice`.",21,N],[11,"len","","Returns the number of elements in the slice.",22,[[["self"]],["usize"]]],[11,"is_empty","","Returns `true` if the slice has a length of 0.",22,[[["self"]],["bool"]]],[11,"as_ptr","","Return a raw device-pointer to the slice's buffer.",22,N],[11,"as_mut_ptr","","Returns an unsafe mutable device-pointer to the slice's buffer.",22,N],[11,"split_at","","Divides one DeviceSlice into two at a given index.",22,N],[11,"split_at_mut","","Divides one mutable DeviceSlice into two at a given index.",22,N],[11,"chunks","","Returns an iterator over `chunk_size` elements of the slice at a time. The chunks are device slices and do not overlap. If `chunk_size` does not divide the length of the slice, then the last chunk will not have length `chunk_size`.",22,[[["self"],["usize"]],["devicechunks"]]],[11,"chunks_mut","","Returns an iterator over `chunk_size` elements of the slice at a time. The chunks are mutable device slices and do not overlap. If `chunk_size` does not divide the length of the slice, then the last chunk will not have length `chunk_size`.",22,[[["self"],["usize"]],["devicechunksmut"]]],[11,"as_device_ptr","","Returns a `DevicePointer<T>` to the buffer.",22,[[["self"]],["devicepointer"]]],[11,"from_raw_parts","","Forms a slice from a `DevicePointer` and a length.",22,[[["devicepointer"],["usize"]],["deviceslice"]]],[11,"from_raw_parts_mut","","Performs the same functionality as `from_raw_parts`, except that a mutable slice is returned.",22,[[["devicepointer"],["usize"]],["deviceslice"]]],[11,"new","","Allocate a new page-locked buffer large enough to hold `size` `T`'s and initialized with clones of `value`.",23,[[["t"],["usize"]],["cudaresult"]]],[11,"from_slice","","Allocate a new page-locked buffer of the same size as `slice`, initialized with a clone of the data in `slice`.",23,N],[11,"uninitialized","","Allocate a new page-locked buffer large enough to hold `size` `T`'s, but without initializing the contents.",23,[[["usize"]],["cudaresult"]]],[11,"as_slice","","Extracts a slice containing the entire buffer.",23,N],[11,"as_mut_slice","","Extracts a mutable slice of the entire buffer.",23,N],[11,"from_raw_parts","","Creates a `LockedBuffer<T>` directly from the raw components of another locked buffer.",23,N],[11,"drop","","Destroy a `LockedBuffer`, returning an error.",23,[[["lockedbuffer"]],["dropresult",["lockedbuffer"]]]],[11,"new","","Allocate unified memory and place val into it.",24,[[["t"]],["cudaresult"]]],[11,"uninitialized","","Allocate unified memory without initializing it.",24,[[],["cudaresult"]]],[11,"from_raw","","Constructs a UnifiedBox from a raw pointer.",24,N],[11,"from_unified","","Constructs a UnifiedBox from a UnifiedPointer.",24,[[["unifiedpointer"]],["self"]]],[11,"into_unified","","Consumes the UnifiedBox, returning the wrapped UnifiedPointer.",24,[[["unifiedbox"]],["unifiedpointer"]]],[11,"as_unified_ptr","","Returns the contained unified pointer without consuming the box.",24,[[["self"]],["unifiedpointer"]]],[11,"leak","","Consumes and leaks the UnifiedBox, returning a mutable reference, &'a mut T. Note that the type T must outlive the chosen lifetime 'a. If the type has only static references, or none at all, this may be chosen to be 'static.",24,[[["unifiedbox"]],["t"]]],[11,"drop","","Destroy a `UnifiedBox`, returning an error.",24,[[["unifiedbox"]],["dropresult",["unifiedbox"]]]],[11,"new","","Allocate a new unified buffer large enough to hold `size` `T`'s and initialized with clones of `value`.",25,[[["t"],["usize"]],["cudaresult"]]],[11,"from_slice","","Allocate a new unified buffer of the same size as `slice`, initialized with a clone of the data in `slice`.",25,N],[11,"uninitialized","","Allocate a new unified buffer large enough to hold `size` `T`'s, but without initializing the contents.",25,[[["usize"]],["cudaresult"]]],[11,"as_slice","","Extracts a slice containing the entire buffer.",25,N],[11,"as_mut_slice","","Extracts a mutable slice of the entire buffer.",25,N],[11,"as_unified_ptr","","Returns a `UnifiedPointer<T>` to the buffer.",25,[[["self"]],["unifiedpointer"]]],[11,"from_raw_parts","","Creates a `UnifiedBuffer<T>` directly from the raw components of another unified buffer.",25,[[["unifiedpointer"],["usize"]],["unifiedbuffer"]]],[11,"drop","","Destroy a `UnifiedBuffer`, returning an error.",25,[[["unifiedbuffer"]],["dropresult",["unifiedbuffer"]]]],[8,"CopyDestination","","Sealed trait implemented by types which can be the source or destination when copying data to/from the device or from one device allocation to another.",N,N],[10,"copy_from","","Copy data from `source`. `source` must be the same size as `self`.",26,[[["self"],["o"]],["cudaresult"]]],[10,"copy_to","","Copy data to `dest`. `dest` must be the same size as `self`.",26,[[["self"],["o"]],["cudaresult"]]],[0,"module","rustacuda","Functions and types for working with CUDA modules.",N,N],[3,"Module","rustacuda::module","A compiled CUDA module, loaded into a context.",N,N],[3,"Symbol","","Handle to a symbol defined within a CUDA module.",N,N],[11,"load_from_file","","Load a module from the given file name into the current context.",27,[[["cstr"]],["cudaresult",["module"]]]],[11,"load_from_string","","Load a module from a CStr.",27,[[["cstr"]],["cudaresult",["module"]]]],[11,"get_global","","Get a reference to a global symbol, which can then be copied to/from.",27,[[["self"],["cstr"]],["cudaresult",["symbol"]]]],[11,"get_function","","Get a reference to a kernel function which can then be launched.",27,[[["self"],["cstr"]],["cudaresult",["function"]]]],[11,"drop","","Destroy a `Module`, returning an error.",27,[[["module"]],["dropresult",["module"]]]],[0,"prelude","rustacuda","This module re-exports a number of commonly-used types for working with RustaCUDA.",N,N],[3,"DeviceBuffer","rustacuda::prelude","Fixed-size device-side buffer. Provides basic access to device memory.",N,N],[3,"UnifiedBuffer","","Fixed-size buffer in unified memory.",N,N],[8,"CopyDestination","","Sealed trait implemented by types which can be the source or destination when copying data to/from the device or from one device allocation to another.",N,N],[10,"copy_from","","Copy data from `source`. `source` must be the same size as `self`.",26,[[["self"],["o"]],["cudaresult"]]],[10,"copy_to","","Copy data to `dest`. `dest` must be the same size as `self`.",26,[[["self"],["o"]],["cudaresult"]]],[0,"stream","rustacuda","Streams of work for the device to perform.",N,N],[3,"StreamFlags","rustacuda::stream","Bit flags for configuring a CUDA Stream.",N,N],[3,"Stream","","A stream of work for the device to perform.",N,N],[18,"DEFAULT","","No flags set.",28,N],[18,"NON_BLOCKING","","This stream does not synchronize with the NULL stream.",28,N],[11,"empty","","Returns an empty set of flags.",28,[[],["streamflags"]]],[11,"all","","Returns the set containing all flags.",28,[[],["streamflags"]]],[11,"bits","","Returns the raw value of the flags currently stored.",28,[[["self"]],["u32"]]],[11,"from_bits","","Convert from underlying bit representation, unless that representation contains bits that do not correspond to a flag.",28,[[["u32"]],["option",["streamflags"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits that do not correspond to flags.",28,[[["u32"]],["streamflags"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",28,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",28,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",28,[[["self"],["streamflags"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",28,[[["self"],["streamflags"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",28,[[["self"],["streamflags"]]]],[11,"remove","","Removes the specified flags in-place.",28,[[["self"],["streamflags"]]]],[11,"toggle","","Toggles the specified flags in-place.",28,[[["self"],["streamflags"]]]],[11,"set","","Inserts or removes the specified flags depending on the passed value.",28,[[["self"],["streamflags"],["bool"]]]],[11,"new","","Create a new stream with the given flags and optional priority.",29,[[["streamflags"],["option",["i32"]]],["cudaresult"]]],[11,"get_flags","","Return the flags which were used to create this stream.",29,[[["self"]],["cudaresult",["streamflags"]]]],[11,"get_priority","","Return the priority of this stream.",29,[[["self"]],["cudaresult",["i32"]]]],[11,"add_callback","","Add a callback to a stream.",29,[[["self"],["box"]],["cudaresult"]]],[11,"synchronize","","Wait until a stream's tasks are completed.",29,[[["self"]],["cudaresult"]]],[11,"drop","","Destroy a `Stream`, returning an error.",29,[[["stream"]],["dropresult",["stream"]]]],[11,"empty","rustacuda","Returns an empty set of flags.",30,[[],["cudaflags"]]],[11,"all","","Returns the set containing all flags.",30,[[],["cudaflags"]]],[11,"bits","","Returns the raw value of the flags currently stored.",30,[[["self"]],["u32"]]],[11,"from_bits","","Convert from underlying bit representation, unless that representation contains bits that do not correspond to a flag.",30,[[["u32"]],["option",["cudaflags"]]]],[11,"from_bits_truncate","","Convert from underlying bit representation, dropping any bits that do not correspond to flags.",30,[[["u32"]],["cudaflags"]]],[11,"is_empty","","Returns `true` if no flags are currently stored.",30,[[["self"]],["bool"]]],[11,"is_all","","Returns `true` if all flags are currently set.",30,[[["self"]],["bool"]]],[11,"intersects","","Returns `true` if there are flags common to both `self` and `other`.",30,[[["self"],["cudaflags"]],["bool"]]],[11,"contains","","Returns `true` all of the flags in `other` are contained within `self`.",30,[[["self"],["cudaflags"]],["bool"]]],[11,"insert","","Inserts the specified flags in-place.",30,[[["self"],["cudaflags"]]]],[11,"remove","","Removes the specified flags in-place.",30,[[["self"],["cudaflags"]]]],[11,"toggle","","Toggles the specified flags in-place.",30,[[["self"],["cudaflags"]]]],[11,"set","","Inserts or removes the specified flags depending on the passed value.",30,[[["self"],["cudaflags"],["bool"]]]],[11,"get","","Returns the latest CUDA version supported by the CUDA driver.",31,[[],["cudaresult",["cudaapiversion"]]]],[11,"major","","Return the major version number - eg. the 9 in version 9.2",31,[[["self"]],["i32"]]],[11,"minor","","Return the minor version number - eg. the 2 in version 9.2",31,[[["self"]],["i32"]]],[14,"launch","","Launch a kernel function asynchronously.",N,N],[11,"into","","",30,[[["self"]],["u"]]],[11,"to_owned","","",30,[[["self"]],["t"]]],[11,"clone_into","","",30,N],[11,"from","","",30,[[["t"]],["t"]]],[11,"try_from","","",30,[[["u"]],["result"]]],[11,"borrow","","",30,[[["self"]],["t"]]],[11,"get_type_id","","",30,[[["self"]],["typeid"]]],[11,"try_into","","",30,[[["self"]],["result"]]],[11,"borrow_mut","","",30,[[["self"]],["t"]]],[11,"into","","",31,[[["self"]],["u"]]],[11,"to_owned","","",31,[[["self"]],["t"]]],[11,"clone_into","","",31,N],[11,"from","","",31,[[["t"]],["t"]]],[11,"try_from","","",31,[[["u"]],["result"]]],[11,"borrow","","",31,[[["self"]],["t"]]],[11,"get_type_id","","",31,[[["self"]],["typeid"]]],[11,"try_into","","",31,[[["self"]],["result"]]],[11,"borrow_mut","","",31,[[["self"]],["t"]]],[11,"into","rustacuda::context","",4,[[["self"]],["u"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,N],[11,"from","","",4,[[["t"]],["t"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"to_owned","","",6,[[["self"]],["t"]]],[11,"clone_into","","",6,N],[11,"from","","",6,[[["t"]],["t"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"from","","",8,[[["t"]],["t"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"from","","",2,[[["t"]],["t"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,N],[11,"from","","",3,[[["t"]],["t"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"into","rustacuda::device","",10,[[["self"]],["u"]]],[11,"to_owned","","",10,[[["self"]],["t"]]],[11,"clone_into","","",10,N],[11,"from","","",10,[[["t"]],["t"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"into","","",32,[[["self"]],["u"]]],[11,"to_owned","","",32,[[["self"]],["t"]]],[11,"clone_into","","",32,N],[11,"from","","",32,[[["t"]],["t"]]],[11,"into_iter","","",32,[[["self"]],["i"]]],[11,"try_from","","",32,[[["u"]],["result"]]],[11,"borrow","","",32,[[["self"]],["t"]]],[11,"get_type_id","","",32,[[["self"]],["typeid"]]],[11,"try_into","","",32,[[["self"]],["result"]]],[11,"borrow_mut","","",32,[[["self"]],["t"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"to_owned","","",9,[[["self"]],["t"]]],[11,"clone_into","","",9,N],[11,"from","","",9,[[["t"]],["t"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"into","rustacuda::error","",11,[[["self"]],["u"]]],[11,"to_string","","",11,[[["self"]],["string"]]],[11,"to_owned","","",11,[[["self"]],["t"]]],[11,"clone_into","","",11,N],[11,"from","","",11,[[["t"]],["t"]]],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"get_type_id","","",11,[[["self"]],["typeid"]]],[11,"try_into","","",11,[[["self"]],["result"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"into","rustacuda::function","",12,[[["self"]],["u"]]],[11,"to_owned","","",12,[[["self"]],["t"]]],[11,"clone_into","","",12,N],[11,"from","","",12,[[["t"]],["t"]]],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"get_type_id","","",12,[[["self"]],["typeid"]]],[11,"try_into","","",12,[[["self"]],["result"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"into","","",13,[[["self"]],["u"]]],[11,"to_owned","","",13,[[["self"]],["t"]]],[11,"clone_into","","",13,N],[11,"from","","",13,[[["t"]],["t"]]],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"get_type_id","","",13,[[["self"]],["typeid"]]],[11,"try_into","","",13,[[["self"]],["result"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"into","","",15,[[["self"]],["u"]]],[11,"from","","",15,[[["t"]],["t"]]],[11,"try_from","","",15,[[["u"]],["result"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"get_type_id","","",15,[[["self"]],["typeid"]]],[11,"try_into","","",15,[[["self"]],["result"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"into","","",14,[[["self"]],["u"]]],[11,"to_owned","","",14,[[["self"]],["t"]]],[11,"clone_into","","",14,N],[11,"from","","",14,[[["t"]],["t"]]],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"get_type_id","","",14,[[["self"]],["typeid"]]],[11,"try_into","","",14,[[["self"]],["result"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"into","rustacuda::memory","",33,[[["self"]],["u"]]],[11,"to_owned","","",33,[[["self"]],["t"]]],[11,"clone_into","","",33,N],[11,"from","","",33,[[["t"]],["t"]]],[11,"try_from","","",33,[[["u"]],["result"]]],[11,"borrow","","",33,[[["self"]],["t"]]],[11,"get_type_id","","",33,[[["self"]],["typeid"]]],[11,"try_into","","",33,[[["self"]],["result"]]],[11,"borrow_mut","","",33,[[["self"]],["t"]]],[11,"into","","",34,[[["self"]],["u"]]],[11,"to_owned","","",34,[[["self"]],["t"]]],[11,"clone_into","","",34,N],[11,"from","","",34,[[["t"]],["t"]]],[11,"try_from","","",34,[[["u"]],["result"]]],[11,"borrow","","",34,[[["self"]],["t"]]],[11,"get_type_id","","",34,[[["self"]],["typeid"]]],[11,"try_into","","",34,[[["self"]],["result"]]],[11,"borrow_mut","","",34,[[["self"]],["t"]]],[11,"into","","",20,[[["self"]],["u"]]],[11,"from","","",20,[[["t"]],["t"]]],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"get_type_id","","",20,[[["self"]],["typeid"]]],[11,"try_into","","",20,[[["self"]],["result"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"into","","",21,[[["self"]],["u"]]],[11,"from","","",21,[[["t"]],["t"]]],[11,"try_from","","",21,[[["u"]],["result"]]],[11,"borrow","","",21,[[["self"]],["t"]]],[11,"get_type_id","","",21,[[["self"]],["typeid"]]],[11,"try_into","","",21,[[["self"]],["result"]]],[11,"borrow_mut","","",21,[[["self"]],["t"]]],[11,"borrow","","",22,[[["self"]],["t"]]],[11,"get_type_id","","",22,[[["self"]],["typeid"]]],[11,"borrow_mut","","",22,[[["self"]],["t"]]],[11,"into","","",35,[[["self"]],["u"]]],[11,"to_owned","","",35,[[["self"]],["t"]]],[11,"clone_into","","",35,N],[11,"from","","",35,[[["t"]],["t"]]],[11,"into_iter","","",35,[[["self"]],["i"]]],[11,"try_from","","",35,[[["u"]],["result"]]],[11,"borrow","","",35,[[["self"]],["t"]]],[11,"get_type_id","","",35,[[["self"]],["typeid"]]],[11,"try_into","","",35,[[["self"]],["result"]]],[11,"borrow_mut","","",35,[[["self"]],["t"]]],[11,"into","","",36,[[["self"]],["u"]]],[11,"from","","",36,[[["t"]],["t"]]],[11,"into_iter","","",36,[[["self"]],["i"]]],[11,"try_from","","",36,[[["u"]],["result"]]],[11,"borrow","","",36,[[["self"]],["t"]]],[11,"get_type_id","","",36,[[["self"]],["typeid"]]],[11,"try_into","","",36,[[["self"]],["result"]]],[11,"borrow_mut","","",36,[[["self"]],["t"]]],[11,"into","","",23,[[["self"]],["u"]]],[11,"from","","",23,[[["t"]],["t"]]],[11,"try_from","","",23,[[["u"]],["result"]]],[11,"borrow","","",23,[[["self"]],["t"]]],[11,"get_type_id","","",23,[[["self"]],["typeid"]]],[11,"try_into","","",23,[[["self"]],["result"]]],[11,"borrow_mut","","",23,[[["self"]],["t"]]],[11,"into","","",24,[[["self"]],["u"]]],[11,"to_string","","",24,[[["self"]],["string"]]],[11,"from","","",24,[[["t"]],["t"]]],[11,"try_from","","",24,[[["u"]],["result"]]],[11,"borrow","","",24,[[["self"]],["t"]]],[11,"get_type_id","","",24,[[["self"]],["typeid"]]],[11,"try_into","","",24,[[["self"]],["result"]]],[11,"borrow_mut","","",24,[[["self"]],["t"]]],[11,"into","","",25,[[["self"]],["u"]]],[11,"from","","",25,[[["t"]],["t"]]],[11,"try_from","","",25,[[["u"]],["result"]]],[11,"borrow","","",25,[[["self"]],["t"]]],[11,"get_type_id","","",25,[[["self"]],["typeid"]]],[11,"try_into","","",25,[[["self"]],["result"]]],[11,"borrow_mut","","",25,[[["self"]],["t"]]],[11,"into","rustacuda::memory::array","",17,[[["self"]],["u"]]],[11,"to_owned","","",17,[[["self"]],["t"]]],[11,"clone_into","","",17,N],[11,"from","","",17,[[["t"]],["t"]]],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"get_type_id","","",17,[[["self"]],["typeid"]]],[11,"try_into","","",17,[[["self"]],["result"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"into","","",18,[[["self"]],["u"]]],[11,"to_owned","","",18,[[["self"]],["t"]]],[11,"clone_into","","",18,N],[11,"from","","",18,[[["t"]],["t"]]],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"get_type_id","","",18,[[["self"]],["typeid"]]],[11,"try_into","","",18,[[["self"]],["result"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"into","","",19,[[["self"]],["u"]]],[11,"from","","",19,[[["t"]],["t"]]],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"get_type_id","","",19,[[["self"]],["typeid"]]],[11,"try_into","","",19,[[["self"]],["result"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"into","","",16,[[["self"]],["u"]]],[11,"to_owned","","",16,[[["self"]],["t"]]],[11,"clone_into","","",16,N],[11,"from","","",16,[[["t"]],["t"]]],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"get_type_id","","",16,[[["self"]],["typeid"]]],[11,"try_into","","",16,[[["self"]],["result"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"into","rustacuda::module","",27,[[["self"]],["u"]]],[11,"from","","",27,[[["t"]],["t"]]],[11,"try_from","","",27,[[["u"]],["result"]]],[11,"borrow","","",27,[[["self"]],["t"]]],[11,"get_type_id","","",27,[[["self"]],["typeid"]]],[11,"try_into","","",27,[[["self"]],["result"]]],[11,"borrow_mut","","",27,[[["self"]],["t"]]],[11,"into","","",37,[[["self"]],["u"]]],[11,"from","","",37,[[["t"]],["t"]]],[11,"try_from","","",37,[[["u"]],["result"]]],[11,"borrow","","",37,[[["self"]],["t"]]],[11,"get_type_id","","",37,[[["self"]],["typeid"]]],[11,"try_into","","",37,[[["self"]],["result"]]],[11,"borrow_mut","","",37,[[["self"]],["t"]]],[11,"into","rustacuda::stream","",28,[[["self"]],["u"]]],[11,"to_owned","","",28,[[["self"]],["t"]]],[11,"clone_into","","",28,N],[11,"from","","",28,[[["t"]],["t"]]],[11,"try_from","","",28,[[["u"]],["result"]]],[11,"borrow","","",28,[[["self"]],["t"]]],[11,"get_type_id","","",28,[[["self"]],["typeid"]]],[11,"try_into","","",28,[[["self"]],["result"]]],[11,"borrow_mut","","",28,[[["self"]],["t"]]],[11,"into","","",29,[[["self"]],["u"]]],[11,"from","","",29,[[["t"]],["t"]]],[11,"try_from","","",29,[[["u"]],["result"]]],[11,"borrow","","",29,[[["self"]],["t"]]],[11,"get_type_id","","",29,[[["self"]],["typeid"]]],[11,"try_into","","",29,[[["self"]],["result"]]],[11,"borrow_mut","","",29,[[["self"]],["t"]]],[11,"partial_cmp","rustacuda::memory","",34,[[["self"],["unifiedpointer"]],["option",["ordering"]]]],[11,"lt","","",34,[[["self"],["unifiedpointer"]],["bool"]]],[11,"le","","",34,[[["self"],["unifiedpointer"]],["bool"]]],[11,"gt","","",34,[[["self"],["unifiedpointer"]],["bool"]]],[11,"ge","","",34,[[["self"],["unifiedpointer"]],["bool"]]],[11,"partial_cmp","","",33,[[["self"],["devicepointer"]],["option",["ordering"]]]],[11,"lt","","",33,[[["self"],["devicepointer"]],["bool"]]],[11,"le","","",33,[[["self"],["devicepointer"]],["bool"]]],[11,"gt","","",33,[[["self"],["devicepointer"]],["bool"]]],[11,"ge","","",33,[[["self"],["devicepointer"]],["bool"]]],[11,"cmp","","",33,[[["self"],["devicepointer"]],["ordering"]]],[11,"cmp","","",34,[[["self"],["unifiedpointer"]],["ordering"]]],[11,"clone","","",34,[[["self"]],["unifiedpointer"]]],[11,"clone","","",33,[[["self"]],["devicepointer"]]],[11,"eq","","",34,[[["self"],["unifiedpointer"]],["bool"]]],[11,"ne","","",34,[[["self"],["unifiedpointer"]],["bool"]]],[11,"eq","","",33,[[["self"],["devicepointer"]],["bool"]]],[11,"ne","","",33,[[["self"],["devicepointer"]],["bool"]]],[11,"fmt","","",33,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",34,[[["self"],["formatter"]],["result",["error"]]]],[11,"hash","","",33,N],[11,"hash","","",34,N],[11,"fmt","","",34,[[["self"],["formatter"]],["result",["error"]]]],[11,"fmt","","",33,[[["self"],["formatter"]],["result",["error"]]]],[11,"get_inner","rustacuda::context","",5,[[["self"]],["cucontext"]]],[11,"get_inner","","",6,[[["self"]],["cucontext"]]],[11,"copy_from","rustacuda::memory","",20,[[["self"],["t"]],["cudaresult"]]],[11,"copy_to","","",20,[[["self"],["t"]],["cudaresult"]]],[11,"copy_from","","",20,[[["self"],["devicebox"]],["cudaresult"]]],[11,"copy_to","","",20,[[["self"],["devicebox"]],["cudaresult"]]],[11,"copy_from","","",22,[[["self"],["i"]],["cudaresult"]]],[11,"copy_to","","",22,[[["self"],["i"]],["cudaresult"]]],[11,"copy_from","","",22,[[["self"],["deviceslice"]],["cudaresult"]]],[11,"copy_to","","",22,[[["self"],["deviceslice"]],["cudaresult"]]],[11,"copy_from","","",22,[[["self"],["devicebuffer"]],["cudaresult"]]],[11,"copy_to","","",22,[[["self"],["devicebuffer"]],["cudaresult"]]],[11,"copy_from","rustacuda::module","",37,[[["self"],["t"]],["cudaresult"]]],[11,"copy_to","","",37,[[["self"],["t"]],["cudaresult"]]],[11,"next","rustacuda::device","",32,[[["self"]],["option",["cudaresult"]]]],[11,"next","rustacuda::memory","",35,[[["self"]],["option",["deviceslice"]]]],[11,"size_hint","","",35,N],[11,"count","","",35,[[["self"]],["usize"]]],[11,"nth","","",35,[[["self"],["usize"]],["option"]]],[11,"last","","",35,[[["self"]],["option"]]],[11,"next","","",36,[[["self"]],["option",["deviceslice"]]]],[11,"size_hint","","",36,N],[11,"count","","",36,[[["self"]],["usize"]]],[11,"nth","","",36,[[["self"],["usize"]],["option"]]],[11,"last","","",36,[[["self"]],["option"]]],[11,"as_mut","","",23,N],[11,"as_mut","","",24,[[["self"]],["t"]]],[11,"as_mut","","",25,N],[11,"partial_cmp","rustacuda::context","",4,[[["self"],["contextflags"]],["option",["ordering"]]]],[11,"lt","","",4,[[["self"],["contextflags"]],["bool"]]],[11,"le","","",4,[[["self"],["contextflags"]],["bool"]]],[11,"gt","","",4,[[["self"],["contextflags"]],["bool"]]],[11,"ge","","",4,[[["self"],["contextflags"]],["bool"]]],[11,"partial_cmp","rustacuda::memory::array","",17,[[["self"],["arrayobjectflags"]],["option",["ordering"]]]],[11,"lt","","",17,[[["self"],["arrayobjectflags"]],["bool"]]],[11,"le","","",17,[[["self"],["arrayobjectflags"]],["bool"]]],[11,"gt","","",17,[[["self"],["arrayobjectflags"]],["bool"]]],[11,"ge","","",17,[[["self"],["arrayobjectflags"]],["bool"]]],[11,"partial_cmp","rustacuda::memory","",24,[[["self"],["unifiedbox"]],["option",["ordering"]]]],[11,"lt","","",24,[[["self"],["unifiedbox"]],["bool"]]],[11,"le","","",24,[[["self"],["unifiedbox"]],["bool"]]],[11,"ge","","",24,[[["self"],["unifiedbox"]],["bool"]]],[11,"gt","","",24,[[["self"],["unifiedbox"]],["bool"]]],[11,"partial_cmp","rustacuda::stream","",28,[[["self"],["streamflags"]],["option",["ordering"]]]],[11,"lt","","",28,[[["self"],["streamflags"]],["bool"]]],[11,"le","","",28,[[["self"],["streamflags"]],["bool"]]],[11,"gt","","",28,[[["self"],["streamflags"]],["bool"]]],[11,"ge","","",28,[[["self"],["streamflags"]],["bool"]]],[11,"partial_cmp","rustacuda","",30,[[["self"],["cudaflags"]],["option",["ordering"]]]],[11,"lt","","",30,[[["self"],["cudaflags"]],["bool"]]],[11,"le","","",30,[[["self"],["cudaflags"]],["bool"]]],[11,"gt","","",30,[[["self"],["cudaflags"]],["bool"]]],[11,"ge","","",30,[[["self"],["cudaflags"]],["bool"]]],[11,"partial_cmp","","",31,[[["self"],["cudaapiversion"]],["option",["ordering"]]]],[11,"lt","","",31,[[["self"],["cudaapiversion"]],["bool"]]],[11,"le","","",31,[[["self"],["cudaapiversion"]],["bool"]]],[11,"gt","","",31,[[["self"],["cudaapiversion"]],["bool"]]],[11,"ge","","",31,[[["self"],["cudaapiversion"]],["bool"]]],[11,"default","rustacuda::memory::array","",17,[[],["arrayobjectflags"]]],[11,"next_back","rustacuda::memory","",35,[[["self"]],["option",["deviceslice"]]]],[11,"next_back","","",36,[[["self"]],["option",["deviceslice"]]]],[11,"cmp","rustacuda::context","",4,[[["self"],["contextflags"]],["ordering"]]],[11,"cmp","rustacuda::memory::array","",17,[[["self"],["arrayobjectflags"]],["ordering"]]],[11,"cmp","rustacuda::memory","",24,[[["self"],["unifiedbox"]],["ordering"]]],[11,"cmp","rustacuda::stream","",28,[[["self"],["streamflags"]],["ordering"]]],[11,"cmp","rustacuda","",30,[[["self"],["cudaflags"]],["ordering"]]],[11,"cmp","","",31,[[["self"],["cudaapiversion"]],["ordering"]]],[11,"eq","rustacuda::context","",1,[[["self"],["cacheconfig"]],["bool"]]],[11,"eq","","",2,[[["self"],["resourcelimit"]],["bool"]]],[11,"eq","","",3,[[["self"],["sharedmemoryconfig"]],["bool"]]],[11,"eq","","",4,[[["self"],["contextflags"]],["bool"]]],[11,"ne","","",4,[[["self"],["contextflags"]],["bool"]]],[11,"eq","","",0,[[["self"],["streampriorityrange"]],["bool"]]],[11,"ne","","",0,[[["self"],["streampriorityrange"]],["bool"]]],[11,"eq","rustacuda::device","",9,[[["self"],["deviceattribute"]],["bool"]]],[11,"eq","","",10,[[["self"],["device"]],["bool"]]],[11,"ne","","",10,[[["self"],["device"]],["bool"]]],[11,"eq","rustacuda::error","",11,[[["self"],["cudaerror"]],["bool"]]],[11,"eq","rustacuda::function","",12,[[["self"],["gridsize"]],["bool"]]],[11,"ne","","",12,[[["self"],["gridsize"]],["bool"]]],[11,"eq","","",13,[[["self"],["blocksize"]],["bool"]]],[11,"ne","","",13,[[["self"],["blocksize"]],["bool"]]],[11,"eq","","",14,[[["self"],["functionattribute"]],["bool"]]],[11,"eq","rustacuda::memory::array","",16,[[["self"],["arrayformat"]],["bool"]]],[11,"eq","","",17,[[["self"],["arrayobjectflags"]],["bool"]]],[11,"ne","","",17,[[["self"],["arrayobjectflags"]],["bool"]]],[11,"eq","rustacuda::memory","",24,[[["self"],["unifiedbox"]],["bool"]]],[11,"eq","rustacuda::stream","",28,[[["self"],["streamflags"]],["bool"]]],[11,"ne","","",28,[[["self"],["streamflags"]],["bool"]]],[11,"eq","rustacuda","",30,[[["self"],["cudaflags"]],["bool"]]],[11,"ne","","",30,[[["self"],["cudaflags"]],["bool"]]],[11,"eq","","",31,[[["self"],["cudaapiversion"]],["bool"]]],[11,"ne","","",31,[[["self"],["cudaapiversion"]],["bool"]]],[11,"from","rustacuda::function","",12,[[["u32"]],["gridsize"]]],[11,"from","","",12,N],[11,"from","","",12,N],[11,"from","","",12,[[["gridsize"]],["gridsize"]]],[11,"from","","",13,[[["u32"]],["blocksize"]]],[11,"from","","",13,N],[11,"from","","",13,N],[11,"from","","",13,[[["blocksize"]],["blocksize"]]],[11,"as_ref","rustacuda::memory","",23,N],[11,"as_ref","","",24,[[["self"]],["t"]]],[11,"as_ref","","",25,N],[11,"clone","rustacuda::context","",1,[[["self"]],["cacheconfig"]]],[11,"clone","","",2,[[["self"]],["resourcelimit"]]],[11,"clone","","",3,[[["self"]],["sharedmemoryconfig"]]],[11,"clone","","",4,[[["self"]],["contextflags"]]],[11,"clone","","",6,[[["self"]],["unownedcontext"]]],[11,"clone","","",0,[[["self"]],["streampriorityrange"]]],[11,"clone","rustacuda::device","",9,[[["self"]],["deviceattribute"]]],[11,"clone","","",10,[[["self"]],["device"]]],[11,"clone","","",32,[[["self"]],["devices"]]],[11,"clone","rustacuda::error","",11,[[["self"]],["cudaerror"]]],[11,"clone","rustacuda::function","",12,[[["self"]],["gridsize"]]],[11,"clone","","",13,[[["self"]],["blocksize"]]],[11,"clone","","",14,[[["self"]],["functionattribute"]]],[11,"clone","rustacuda::memory::array","",16,[[["self"]],["arrayformat"]]],[11,"clone","","",17,[[["self"]],["arrayobjectflags"]]],[11,"clone","","",18,[[["self"]],["arraydescriptor"]]],[11,"clone","rustacuda::memory","",35,[[["self"]],["devicechunks"]]],[11,"clone","rustacuda::stream","",28,[[["self"]],["streamflags"]]],[11,"clone","rustacuda","",30,[[["self"]],["cudaflags"]]],[11,"clone","","",31,[[["self"]],["cudaapiversion"]]],[11,"extend","rustacuda::context","",4,[[["self"],["t"]]]],[11,"extend","rustacuda::memory::array","",17,[[["self"],["t"]]]],[11,"extend","rustacuda::stream","",28,[[["self"],["t"]]]],[11,"extend","rustacuda","",30,[[["self"],["t"]]]],[11,"drop","rustacuda::context","",5,[[["self"]]]],[11,"drop","rustacuda::memory::array","",19,[[["self"]]]],[11,"drop","rustacuda::memory","",20,[[["self"]]]],[11,"drop","","",21,[[["self"]]]],[11,"drop","","",23,[[["self"]]]],[11,"drop","","",24,[[["self"]]]],[11,"drop","","",25,[[["self"]]]],[11,"drop","rustacuda::module","",27,[[["self"]]]],[11,"drop","rustacuda::stream","",29,[[["self"]]]],[11,"fmt","rustacuda::context","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::memory::array","",17,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::stream","",28,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda","",30,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::error","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::memory","",24,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::context","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::memory::array","",17,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::stream","",28,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda","",30,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::context","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",5,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",6,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::device","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",32,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::error","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::function","",12,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",13,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",14,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",15,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::memory::array","",16,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",17,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",18,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",19,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::memory","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",21,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",22,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",35,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",36,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",23,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",24,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",25,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::module","",27,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",37,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::stream","",28,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",29,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda","",30,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",31,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::memory","",20,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",24,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::module","",37,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::context","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::memory::array","",17,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::stream","",28,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda","",30,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::context","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::memory::array","",17,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda::stream","",28,[[["self"],["formatter"]],["result"]]],[11,"fmt","rustacuda","",30,[[["self"],["formatter"]],["result"]]],[11,"hash","rustacuda::context","",1,N],[11,"hash","","",2,N],[11,"hash","","",3,N],[11,"hash","","",4,N],[11,"hash","","",0,N],[11,"hash","rustacuda::device","",9,N],[11,"hash","","",10,N],[11,"hash","rustacuda::function","",14,N],[11,"hash","rustacuda::memory::array","",17,N],[11,"hash","rustacuda::memory","",24,[[["self"],["h"]]]],[11,"hash","rustacuda::stream","",28,N],[11,"hash","rustacuda","",30,N],[11,"hash","","",31,N],[11,"sub","rustacuda::context","Returns the set difference of the two sets of flags.",4,[[["self"],["contextflags"]],["contextflags"]]],[11,"sub","rustacuda::memory::array","Returns the set difference of the two sets of flags.",17,[[["self"],["arrayobjectflags"]],["arrayobjectflags"]]],[11,"sub","rustacuda::stream","Returns the set difference of the two sets of flags.",28,[[["self"],["streamflags"]],["streamflags"]]],[11,"sub","rustacuda","Returns the set difference of the two sets of flags.",30,[[["self"],["cudaflags"]],["cudaflags"]]],[11,"sub_assign","rustacuda::context","Disables all flags enabled in the set.",4,[[["self"],["contextflags"]]]],[11,"sub_assign","rustacuda::memory::array","Disables all flags enabled in the set.",17,[[["self"],["arrayobjectflags"]]]],[11,"sub_assign","rustacuda::stream","Disables all flags enabled in the set.",28,[[["self"],["streamflags"]]]],[11,"sub_assign","rustacuda","Disables all flags enabled in the set.",30,[[["self"],["cudaflags"]]]],[11,"not","rustacuda::context","Returns the complement of this set of flags.",4,[[["self"]],["contextflags"]]],[11,"not","rustacuda::memory::array","Returns the complement of this set of flags.",17,[[["self"]],["arrayobjectflags"]]],[11,"not","rustacuda::stream","Returns the complement of this set of flags.",28,[[["self"]],["streamflags"]]],[11,"not","rustacuda","Returns the complement of this set of flags.",30,[[["self"]],["cudaflags"]]],[11,"bitand","rustacuda::context","Returns the intersection between the two sets of flags.",4,[[["self"],["contextflags"]],["contextflags"]]],[11,"bitand","rustacuda::memory::array","Returns the intersection between the two sets of flags.",17,[[["self"],["arrayobjectflags"]],["arrayobjectflags"]]],[11,"bitand","rustacuda::stream","Returns the intersection between the two sets of flags.",28,[[["self"],["streamflags"]],["streamflags"]]],[11,"bitand","rustacuda","Returns the intersection between the two sets of flags.",30,[[["self"],["cudaflags"]],["cudaflags"]]],[11,"bitor","rustacuda::context","Returns the union of the two sets of flags.",4,[[["self"],["contextflags"]],["contextflags"]]],[11,"bitor","rustacuda::memory::array","Returns the union of the two sets of flags.",17,[[["self"],["arrayobjectflags"]],["arrayobjectflags"]]],[11,"bitor","rustacuda::stream","Returns the union of the two sets of flags.",28,[[["self"],["streamflags"]],["streamflags"]]],[11,"bitor","rustacuda","Returns the union of the two sets of flags.",30,[[["self"],["cudaflags"]],["cudaflags"]]],[11,"bitxor","rustacuda::context","Returns the left flags, but with all the right flags toggled.",4,[[["self"],["contextflags"]],["contextflags"]]],[11,"bitxor","rustacuda::memory::array","Returns the left flags, but with all the right flags toggled.",17,[[["self"],["arrayobjectflags"]],["arrayobjectflags"]]],[11,"bitxor","rustacuda::stream","Returns the left flags, but with all the right flags toggled.",28,[[["self"],["streamflags"]],["streamflags"]]],[11,"bitxor","rustacuda","Returns the left flags, but with all the right flags toggled.",30,[[["self"],["cudaflags"]],["cudaflags"]]],[11,"bitand_assign","rustacuda::context","Disables all flags disabled in the set.",4,[[["self"],["contextflags"]]]],[11,"bitand_assign","rustacuda::memory::array","Disables all flags disabled in the set.",17,[[["self"],["arrayobjectflags"]]]],[11,"bitand_assign","rustacuda::stream","Disables all flags disabled in the set.",28,[[["self"],["streamflags"]]]],[11,"bitand_assign","rustacuda","Disables all flags disabled in the set.",30,[[["self"],["cudaflags"]]]],[11,"bitor_assign","rustacuda::context","Adds the set of flags.",4,[[["self"],["contextflags"]]]],[11,"bitor_assign","rustacuda::memory::array","Adds the set of flags.",17,[[["self"],["arrayobjectflags"]]]],[11,"bitor_assign","rustacuda::stream","Adds the set of flags.",28,[[["self"],["streamflags"]]]],[11,"bitor_assign","rustacuda","Adds the set of flags.",30,[[["self"],["cudaflags"]]]],[11,"bitxor_assign","rustacuda::context","Toggles the set of flags.",4,[[["self"],["contextflags"]]]],[11,"bitxor_assign","rustacuda::memory::array","Toggles the set of flags.",17,[[["self"],["arrayobjectflags"]]]],[11,"bitxor_assign","rustacuda::stream","Toggles the set of flags.",28,[[["self"],["streamflags"]]]],[11,"bitxor_assign","rustacuda","Toggles the set of flags.",30,[[["self"],["cudaflags"]]]],[11,"deref","rustacuda::memory","",21,[[["self"]],["deviceslice"]]],[11,"deref","","",23,N],[11,"deref","","",24,[[["self"]],["t"]]],[11,"deref","","",25,N],[11,"deref_mut","","",21,[[["self"]],["deviceslice"]]],[11,"deref_mut","","",23,N],[11,"deref_mut","","",24,[[["self"]],["t"]]],[11,"deref_mut","","",25,N],[11,"index","","",22,[[["self"],["range",["usize"]]],["self"]]],[11,"index","","",22,[[["self"],["rangefull"]],["self"]]],[11,"index","","",22,[[["self"],["rangefrom",["usize"]]],["self"]]],[11,"index","","",22,[[["self"],["rangeinclusive",["usize"]]],["self"]]],[11,"index","","",22,[[["self"],["rangeto",["usize"]]],["self"]]],[11,"index","","",22,[[["self"],["rangetoinclusive",["usize"]]],["self"]]],[11,"index_mut","","",22,[[["self"],["range",["usize"]]],["self"]]],[11,"index_mut","","",22,[[["self"],["rangefull"]],["self"]]],[11,"index_mut","","",22,[[["self"],["rangefrom",["usize"]]],["self"]]],[11,"index_mut","","",22,[[["self"],["rangeinclusive",["usize"]]],["self"]]],[11,"index_mut","","",22,[[["self"],["rangeto",["usize"]]],["self"]]],[11,"index_mut","","",22,[[["self"],["rangetoinclusive",["usize"]]],["self"]]],[11,"from_iter","rustacuda::context","",4,[[["t"]],["contextflags"]]],[11,"from_iter","rustacuda::memory::array","",17,[[["t"]],["arrayobjectflags"]]],[11,"from_iter","rustacuda::stream","",28,[[["t"]],["streamflags"]]],[11,"from_iter","rustacuda","",30,[[["t"]],["cudaflags"]]],[11,"borrow","rustacuda::memory","",24,[[["self"]],["t"]]],[11,"borrow_mut","","",24,[[["self"]],["t"]]],[11,"null","","Returns a null device pointer.",33,[[],["devicepointer"]]],[11,"wrap","","Wrap the given raw pointer in a DevicePointer. The given pointer is assumed to be a valid, device pointer or null.",33,N],[11,"as_raw","","Returns the contained pointer as a raw pointer. The returned pointer is not valid on the CPU and must not be dereferenced.",33,N],[11,"as_raw_mut","","Returns the contained pointer as a mutable raw pointer. The returned pointer is not valid on the CPU and must not be dereferenced.",33,N],[11,"is_null","","Returns true if the pointer is null. # Examples:",33,[[["self"]],["bool"]]],[11,"offset","","Calculates the offset from a device pointer.",33,[[["self"],["isize"]],["devicepointer"]]],[11,"wrapping_offset","","Calculates the offset from a device pointer using wrapping arithmetic.",33,[[["self"],["isize"]],["devicepointer"]]],[11,"add","","Calculates the offset from a pointer (convenience for `.offset(count as isize)`).",33,[[["self"],["usize"]],["devicepointer"]]],[11,"sub","","Calculates the offset from a pointer (convenience for `.offset((count as isize).wrapping_neg())`).",33,[[["self"],["usize"]],["devicepointer"]]],[11,"wrapping_add","","Calculates the offset from a pointer using wrapping arithmetic. (convenience for `.wrapping_offset(count as isize)`)",33,[[["self"],["usize"]],["devicepointer"]]],[11,"wrapping_sub","","Calculates the offset from a pointer using wrapping arithmetic. (convenience for `.wrapping_offset((count as isize).wrapping_sub())`)",33,[[["self"],["usize"]],["devicepointer"]]],[11,"null","","Returns a null unified pointer.",34,[[],["unifiedpointer"]]],[11,"wrap","","Wrap the given raw pointer in a UnifiedPointer. The given pointer is assumed to be a valid, unified-memory pointer or null.",34,N],[11,"as_raw","","Returns the contained pointer as a raw pointer.",34,N],[11,"as_raw_mut","","Returns the contained pointer as a mutable raw pointer.",34,N],[11,"is_null","","Returns true if the pointer is null.",34,[[["self"]],["bool"]]],[11,"offset","","Calculates the offset from a unified pointer.",34,[[["self"],["isize"]],["unifiedpointer"]]],[11,"wrapping_offset","","Calculates the offset from a unified pointer using wrapping arithmetic.",34,[[["self"],["isize"]],["unifiedpointer"]]],[11,"add","","Calculates the offset from a pointer (convenience for `.offset(count as isize)`).",34,[[["self"],["usize"]],["unifiedpointer"]]],[11,"sub","","Calculates the offset from a pointer (convenience for `.offset((count as isize).wrapping_neg())`).",34,[[["self"],["usize"]],["unifiedpointer"]]],[11,"wrapping_add","","Calculates the offset from a pointer using wrapping arithmetic. (convenience for `.wrapping_offset(count as isize)`)",34,[[["self"],["usize"]],["unifiedpointer"]]],[11,"wrapping_sub","","Calculates the offset from a pointer using wrapping arithmetic. (convenience for `.wrapping_offset((count as isize).wrapping_sub())`)",34,[[["self"],["usize"]],["unifiedpointer"]]]],"paths":[[3,"StreamPriorityRange"],[4,"CacheConfig"],[4,"ResourceLimit"],[4,"SharedMemoryConfig"],[3,"ContextFlags"],[3,"Context"],[3,"UnownedContext"],[3,"ContextStack"],[3,"CurrentContext"],[4,"DeviceAttribute"],[3,"Device"],[4,"CudaError"],[3,"GridSize"],[3,"BlockSize"],[4,"FunctionAttribute"],[3,"Function"],[4,"ArrayFormat"],[3,"ArrayObjectFlags"],[3,"ArrayDescriptor"],[3,"ArrayObject"],[3,"DeviceBox"],[3,"DeviceBuffer"],[3,"DeviceSlice"],[3,"LockedBuffer"],[3,"UnifiedBox"],[3,"UnifiedBuffer"],[8,"CopyDestination"],[3,"Module"],[3,"StreamFlags"],[3,"Stream"],[3,"CudaFlags"],[3,"CudaApiVersion"],[3,"Devices"],[3,"DevicePointer"],[3,"UnifiedPointer"],[3,"DeviceChunks"],[3,"DeviceChunksMut"],[3,"Symbol"]]};
initSearch(searchIndex);
